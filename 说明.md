# 使用

## exp_1  locality

两个程序

t1.cpp t2.cpp

参数N定义了大小。

编译运行，然后分析数据即可。

## exp_2  replacer

定义了两个算法 LRU 和 clock 算法。

运行make即可。

## exp_3  pagemap

```
g++ hw.cpp -o hw
g++ test.cpp -o test
sudo ./hw test
```

记得加sudo，不然读取不了页表数据。

# 编写二维数组遍历程序

## 程序

t1.cpp

```C++
#include<bits/stdc++.h>
using namespace std;
#define N 2048
int MyArray[N][N];

int main() {
    for(int i = 0;i < N;i++)
        for(int j = 0;j <= N;j++) {
            MyArray[i][j] = 0;
        }
}
```

t2.cpp

```C++
#include<bits/stdc++.h>
using namespace std;
#define N 2048
int MyArray[N][N];

int main() {
    for(int i = 0;i < N;i++)
        for(int j = 0;j <= N;j++) {
            MyArray[j][i] = 0;
        }
}
```

## 如何查看缺页次数

### ps



```shell
ps -o min_flt,maj_flt $pid

//可以看到所有进程的相关信息
ps -eo min_flt,maj_flt,cmd,args,uid,gid | less
```

min_flt：小的缺页，此类缺页对程序性能影响较小，因为不需要从磁盘上读取响应文件装载到内存中，只需要物理内存分配空间即可。

maj_flt：大的缺页，此类缺页对程序性能影响较大，需要从磁盘上读取文件装载到内存中。

### sar

```shell
sudo apt install sysstat
sar -B 1 10
sar -B 1
```

### time

​	type: shell built-in command

![image-20211203134026105](/home/yy/.config/Typora/typora-user-images/image-20211203134026105.png)

​	Use the /usr/bin/time command (do not use shell built-in time command)  to run programs and summarize system resource usage include  page faults. First, find out path to real time command:

```
/usr/bin/time -v $command
/usr/bin/time -v ls
```

![image-20211203134224503](/home/yy/.config/Typora/typora-user-images/image-20211203134224503.png)

## N=2048

运行t1代码

```shell
/usr/bin/time -v ./t1
```

![image-20211203134503382](/home/yy/.config/Typora/typora-user-images/image-20211203134503382.png)

运行t2代码

![image-20211203134546013](/home/yy/.config/Typora/typora-user-images/image-20211203134546013.png)

## N = 10240

![image-20211203135255451](/home/yy/.config/Typora/typora-user-images/image-20211203135255451.png)

对比关键参数

User time ： 用户态运行时间

System time：系统态运行时间

Elapsed time：总运行时间

Major Plt：需要磁盘IO的缺页

Minor Plt：需要分配物理内存的缺页

对比关键数据，得到结论：

- v2花费了更多运行时间
- v1和v2缺页次数一致

​	题目要求比较缺页次数，但是目前电脑内存都比较大，本机12G内存，因此10240 * 10240 * 4 / 1024 / 1024 =  400M 计算机内存完全可以放下,因此不会发生缺页。

​	但是计算机的高速缓存没有这么大的空间

![image-20211203140304297](/home/yy/.config/Typora/typora-user-images/image-20211203140304297.png) 

因此可以知道告诉缓存的空间大小限制了两个程序的内存访问速度。

因此**局部性更好**的t1运行时间更短，局部性差的t2时间更长。

# 模拟OPT和LRU淘汰算法

![image-20211203141336176](/home/yy/.config/Typora/typora-user-images/image-20211203141336176.png)

程序指令的执行过程采用遍历数组的操作来模拟

模拟指令的执行

必须是设定页的大小的整数倍

小数组里面复制的是大数组里面的赌赢页面内容。

页表

访问

![image-20211203153129353](/home/yy/.config/Typora/typora-user-images/image-20211203153129353.png)

## 虚函数定义替换算法

```C++
class Replacer {
    public:
    	Replacer() = default;
    	virtual pgid victim() = 0; //逐出哪个物理页
    	virtual void lru_visit(pgid pgnum); //访问过哪个物理页
}

```

![image-20211203182042876](/home/yy/.config/Typora/typora-user-images/image-20211203182042876.png)

这几个关键词什么意思

描述：override保留字表示当前函数重写了基类的虚函数。

explicit

https://www.cnblogs.com/rednodel/p/9299251.html



LRU: 最近最少使用算法	

​	LRU算法的思想也很简单，实现一个链表（双向链表），每次要缓冲新的页面时，遍历链表，选择**最近**最少使用的页面进行逐出操作。

​	最近：是说找到一个页面，其他页面都是使用过了，就剩它自己没有使用过了。

​	这种算法要求每个页面上记录一个上次使用时间t，程序决定逐出时，以这个时间t为准，t距离当前时间最大的，就是要被逐出的页面。

记录一个时间。

CLOCK:时钟替换算法

​	时钟置换算法可以认为是一种最近未使用算法，即逐出的页面都是最近没有使用的那个。

​	我们给每一个页面设置一个标记位u，u=1表示最近有使用u=0则表示该页面最近没有被使用，应该被逐出。

​	最初要经过一轮遍历，每次遍历到一个节点发现u=1的，将该标记位置为0，然后遍历下一个页面，一轮遍历完后，发现没有可以被逐出的页面，则进行下一轮遍历，这次遍历之后发现原先1号页面的标记位u=0，则将该页面逐出，置换为页面5，并将指针指向下一个页面。 

​	上图中，星号表示引用位为1；灰色块表示占用，蓝色块表示可以置换；**箭头指向的是下次发生缺页中断时开始检查的地方，如果可以发生置换，则在该位置置换，不能的话就向前挪**；红色框表示下次置换发生的位置。

![preview](https://pic2.zhimg.com/v2-f86c42d1151d091d2272014e7b0f94a9_r.jpg)



## LRU算法

```C++
void init_lru();
pgid victim(int vptx); //替换一页算法，将vptx载入
void lru_visit(int pgnum); //访问某一页，将其放到最后
```

## OPT算法

​	OPT（最佳置换算法）：从主存中移出永远不再需要的页面，如果没有这样的页面存在，那就选择最长时间不需要访问的页面，来保证最低的缺页率



![image-20211203232648576](/home/yy/.config/Typora/typora-user-images/image-20211203232648576.png)

为什么会有值在

# pagemap

![image-20211203234121078](/home/yy/.config/Typora/typora-user-images/image-20211203234121078.png)

​	pagemap is a new (as of 2.6.25) set of interfaces in the kernel that allow
userspace programs to examine the page tables and related information by
reading files in /proc.

​	This file lets a userspace process find out which physical frame each virtual page is mapped to.  It contains one 64-bit value for each virtual page, containing the following data (from fs/proc/task_mmu.c, above pagemap_read):

* Bits 0-54  page frame number (PFN) if present
* Bits 0-4   swap type if swapped  如果交换了 那么请说出交换的类型
* Bits 5-54  swap offset if swapped  交换的偏移
* Bit  55    pte is soft-dirty (see Documentation/vm/soft-dirty.txt)
* Bit  56    page exclusively mapped (since 4.2)
* Bits 57-60 zero
* Bit  61    page is file-page or shared-anon (since 3.5)
* Bit  62    page swapped
* Bit  63    page present

得到环境变量的值

## 参考函数

sysconf获取环境变量的值

```C++
/* Get the value of the system variable NAME.  */
extern long int sysconf (int __name) __THROW;
```

pread读取

![image-20211204093459901](/home/yy/.config/Typora/typora-user-images/image-20211204093459901.png)

![image-20211204163516067](/home/yy/.config/Typora/typora-user-images/image-20211204163516067.png)

# 运行时库

pldd

dlclose (3)          - open and close a shared object
dlmopen (3)          - open and close a shared object
dlopen (3)           - open and close a shared object
dlsym (3)            - obtain address of a symbol in a shared object or executable
dlvsym (3)           - obtain address of a symbol in a shared object or executable

![image-20211204162609337](/home/yy/.config/Typora/typora-user-images/image-20211204162609337.png)

![image-20211204164242512](/home/yy/.config/Typora/typora-user-images/image-20211204164242512.png)



运行完被删除 是咋回事

vscode debug

![image-20211204170653665](/home/yy/.config/Typora/typora-user-images/image-20211204170653665.png)

返回的是我的虚拟地址

![image-20211204171105058](/home/yy/.config/Typora/typora-user-images/image-20211204171105058.png)

# 参考

缺页分析程序：

https://www.cyberciti.biz/faq/linux-command-to-see-major-minor-pagefaults/

shell循环语句

https://www.cnblogs.com/EasonJim/p/8315939.html

C++虚函数

http://c.biancheng.net/cpp/biancheng/view/2770.html

pagemap文件格式

https://www.kernel.org/doc/Documentation/vm/pagemap.txt

https://stackoverflow.com/questions/5748492/is-there-any-api-for-determining-the-physical-address-from-virtual-address-in-li/45128487#45128487

读取函数名和对应的地址

https://blog.csdn.net/Chasing_Chasing/article/details/96750109

https://stackoverflow.com/questions/17637745/can-a-program-read-its-own-elf-section

https://stackoverflow.com/questions/29052125/reading-the-contents-of-an-elf-sectionprogrammatically

read elf symbol header in cpp

读取一个命令对应的输出，要怎么办。

怎么去包装呢？

https://mryqu.github.io/post/c++_%E4%BD%BF%E7%94%A8readelf/

共享库

https://stackoverflow.com/questions/39943019/function-of-shared-library-is-loaded-at-different-physical-addresses-for-differe

https://stackoverflow.com/questions/36384195/how-to-correctly-assign-a-pointer-returned-by-dlsym-into-a-variable-of-function

https://www.ibm.com/docs/en/zos/2.2.0?topic=functions-dlsym-obtain-address-symbol-from-dlopen-object

https://stackoverflow.com/questions/48975724/how-to-get-address-of-a-symbol-in-a-shared-library-when-provided-address-of-the

https://blog.csdn.net/ustcxiangchun/article/details/6310085

https://docs.oracle.com/cd/E19253-01/819-7050/chapter3-24/