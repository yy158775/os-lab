# 编写二维数组遍历程序

## 程序

t1.cpp

```C++
#include<bits/stdc++.h>
using namespace std;
#define N 2048
int MyArray[N][N];

int main() {
    for(int i = 0;i < N;i++)
        for(int j = 0;j <= N;j++) {
            MyArray[i][j] = 0;
        }
}
```

t2.cpp

```C++
#include<bits/stdc++.h>
using namespace std;
#define N 2048
int MyArray[N][N];

int main() {
    for(int i = 0;i < N;i++)
        for(int j = 0;j <= N;j++) {
            MyArray[j][i] = 0;
        }
}
```

## 如何查看缺页次数

### ps



```shell
ps -o min_flt,maj_flt $pid

//可以看到所有进程的相关信息
ps -eo min_flt,maj_flt,cmd,args,uid,gid | less
```

min_flt：小的缺页，此类缺页对程序性能影响较小，因为不需要从磁盘上读取响应文件装载到内存中，只需要物理内存分配空间即可。

maj_flt：大的缺页，此类缺页对程序性能影响较大，需要从磁盘上读取文件装载到内存中。

### sar

```shell
sudo apt install sysstat
sar -B 1 10
sar -B 1
```

### time

​	type: shell built-in command

![image-20211203134026105](/home/yy/.config/Typora/typora-user-images/image-20211203134026105.png)

​	Use the /usr/bin/time command (do not use shell built-in time command)  to run programs and summarize system resource usage include  page faults. First, find out path to real time command:

```
/usr/bin/time -v $command
/usr/bin/time -v ls
```

![image-20211203134224503](/home/yy/.config/Typora/typora-user-images/image-20211203134224503.png)

## N=2048

运行t1代码

```shell
/usr/bin/time -v ./t1
```

![image-20211203134503382](/home/yy/.config/Typora/typora-user-images/image-20211203134503382.png)

运行t2代码

![image-20211203134546013](/home/yy/.config/Typora/typora-user-images/image-20211203134546013.png)

## N = 10240

![image-20211203135255451](/home/yy/.config/Typora/typora-user-images/image-20211203135255451.png)

对比关键参数

User time ： 用户态运行时间

System time：系统态运行时间

Elapsed time：总运行时间

Major Plt：需要磁盘IO的缺页

Minor Plt：需要分配物理内存的缺页

对比关键数据，得到结论：

- v2花费了更多运行时间
- v1和v2缺页次数一致

​	题目要求比较缺页次数，但是目前电脑内存都比较大，本机12G内存，因此10240 * 10240 * 4 / 1024 / 1024 =  400M 计算机内存完全可以放下,因此不会发生缺页。

​	但是计算机的高速缓存没有这么大的空间

![image-20211203140304297](/home/yy/.config/Typora/typora-user-images/image-20211203140304297.png) 

因此可以知道告诉缓存的空间大小限制了两个程序的内存访问速度。

因此**局部性更好**的t1运行时间更短，局部性差的t2时间更长。

# 模拟OPT和LRU淘汰算法

![image-20211203141336176](/home/yy/.config/Typora/typora-user-images/image-20211203141336176.png)

程序指令的执行过程采用遍历数组的操作来模拟

模拟指令的执行

必须是设定页的大小的整数倍

小数组里面复制的是大数组里面的赌赢页面内容。

页表

访问

![image-20211203153129353](/home/yy/.config/Typora/typora-user-images/image-20211203153129353.png)

## 虚函数定义替换算法

```C++
class Replacer {
    public:
    	Replacer() = default;
    	virtual pgid victim() = 0; //逐出哪个物理页
    	virtual void lru_visit(pgid pgnum); //访问过哪个物理页
}

```





## LRU算法

```C++
void init_lru();
pgid victim(int vptx); //替换一页算法，将vptx载入
void lru_visit(int pgnum); //访问某一页，将其放到最后
```

## OPT算法

​	OPT（最佳置换算法）：从主存中移出永远不再需要的页面，如果没有这样的页面存在，那就选择最长时间不需要访问的页面，来保证最低的缺页率





# 参考

缺页分析程序：

https://www.cyberciti.biz/faq/linux-command-to-see-major-minor-pagefaults/

